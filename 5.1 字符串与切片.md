## 字符串

String 和 &str 不是一个类型

```rust
fn main() {
  let my_name = "Pascal"; // &str 类型字符串
  greet(my_name);
}

fn greet(name: String) { // String 类型字符串
  println!("Hello, {}!", name);
}
```

```rust
error[E0308]: mismatched types
 --> src/main.rs:3:11
  |
3 |     greet(my_name);
  |           ^^^^^^^
  |           |
  |           expected struct `std::string::String`, found `&str`
  |           help: try using a conversion method: `my_name.to_string()`

error: aborting due to previous error
```

## 切片(slice)

.. range 序列语法，左闭右开：

```rust
#![allow(unused)]
fn main() {
	let s = String::from("hello world");
	
	let hello = &s[0..5];
	let world = &s[6..11];
}
```

从第 0 个开始：

```rust
#![allow(unused)]
fn main() {
	let s = String::from("hello");
	
	let slice = &s[0..2];
	let slice = &s[..2];
}
```

截取完整的 String 切片：

```rust
#![allow(unused)]
fn main() {
	let s = String::from("hello");
	
	let len = s.len();
	
	let slice = &s[0..len];
	let slice = &s[..];
}
```

注意由于每个汉字占用三个字节，导致中文的索引越界问题：

```rust
#![allow(unused)]
fn main() {
	let s = "中国人";
	let a = &s[0..2]; // byte index 2 is not a char boundary; it is inside '中' (bytes 0..3) of `中国人`
	println!("{}",a);
}
```

### 其他切片

```rust
#![allow(unused)]
fn main() {
	let a = [1, 2, 3, 4, 5];
	
	let slice = &a[1..3]; // 该数组切片的类型是 `&[i32]`
	
	assert_eq!(slice, &[2, 3]);
}
```

## 字符串字面量是切片

```rust
let s = "Hello, world!";
```

实际上，`s` 的类型是 `&str`，因此你也可以这样声明：

```rust
let s: &str = "Hello, world!";
```

该切片指向了程序可执行文件中的某个点，所以字符串字面量是不可变的，因为 `&str` 是一个不可变引用。

## 什么是字符串?

